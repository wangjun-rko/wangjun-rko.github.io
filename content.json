[{"title":"LRU算法","date":"2019-07-02T10:47:10.000Z","path":"2019/07/02/LRU算法/","text":"LRU算法 Least Recently Used 最近最少使用。 一种内存关联算法，最早应用与linux系统。 基于一种假设：长期不被使用的数据，在未来被用到的几率也不高。因此，当数据所占内存达到一定的阈值时，就移除掉最近最少使用的数据。 使用了一种哈希链表的数据结构。 哈希表 由若干个key-value组成，没有所谓的排列顺序。 哈希链表 每个key-value都有它的前驱key-value、后续key-value，类似于双向链表中的节点。原本无序的哈希表有了固定的顺序。 依靠哈希链表的有序性，可以把key-value按照最后使用时间来排序。 例子 先存4个用户，按时间顺序依次从链表右端插入。 业务系统访问用户5，由于没有数据，从数据库取出，插入。此时，链表的最右端是最新访问到的用户5，最左端是最近最少访问的用户1。 业务系统访问用户2，把用户2从原位置移出，重新插入到链表最右端。 业务系统访问用户6，没有数据，从数据库取出。假设链表容量已到上限，须先删除最近最少访问的数据，那么位于最左端的用户1会被删除，然后把用户6插入最右端。 LinkedHashMap就是对哈希链表的实现。Redis底层也实现了类似于LRU的回收算法。 简单代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120public class LRUCache &#123; private Node head; private Node end; //缓存存储上限 private int limit; private HashMap&lt;String, Node&gt; hashMap; public LRUCache(int limit) &#123; this.limit = limit; hashMap = new HashMap&lt;String, Node&gt;(); &#125; public String get(String key) &#123; Node node = hashMap.get(key); if (node == null)&#123; return null; &#125; refreshNode(node); return node.value; &#125; public void put(String key, String value) &#123; Node node = hashMap.get(key); if (node == null) &#123; //如果key不存在，插入key-value if (hashMap.size() &gt;= limit) &#123; String oldKey = removeNode(head); hashMap.remove(oldKey); &#125; node = new Node(key, value); addNode(node); hashMap.put(key, node); &#125;else &#123; //如果key存在，刷新key-value node.value = value; refreshNode(node); &#125; &#125; public void remove(String key) &#123; Node node = hashMap.get(key); removeNode(node); hashMap.remove(key); &#125; /** * 刷新被访问的节点位置 * @param node 被访问的节点 */ private void refreshNode(Node node) &#123; //如果访问的是尾节点，无需移动节点 if (node == end) &#123; return; &#125; //移除节点 removeNode(node); //重新插入节点 addNode(node); &#125; /** * 删除节点 * @param node 要删除的节点 */ private String removeNode(Node node) &#123; if (node == end) &#123; //移除尾节点 end = end.pre; &#125;else if(node == head)&#123; //移除头节点 head = head.next; &#125; else &#123; //移除中间节点 node.pre.next = node.next; node.next.pre = node.pre; &#125; return node.key; &#125; /** * 尾部插入节点 * @param node 要插入的节点 */ private void addNode(Node node) &#123; if(end != null) &#123; end.next = node; node.pre = end; node.next = null; &#125; end = node; if(head == null)&#123; head = node; &#125; &#125; public static void main(String[] args) &#123; LRUCache lruCache = new LRUCache(5); lruCache.put(\"001\", \"用户1\"); lruCache.put(\"002\", \"用户2\"); lruCache.put(\"003\", \"用户3\"); lruCache.put(\"004\", \"用户4\"); lruCache.put(\"005\", \"用户5\"); lruCache.get(\"002\"); lruCache.put(\"002\", \"用户2更新\"); lruCache.put(\"006\", \"用户6\"); System.out.println(lruCache.get(\"001\")); System.out.println(lruCache.get(\"006\")); &#125;&#125;class Node &#123; Node(String key, String value)&#123; this.key = key; this.value = value; &#125; public Node pre; public Node next; public String key; public String value;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://127.0.0.1:4000/tags/算法/"}]},{"title":"MySql中SQL语句执行慢的原因","date":"2019-06-28T06:46:08.000Z","path":"2019/06/28/MySql中SQL语句执行慢的原因/","text":"一、分类 偶尔出现很慢的情况。 一直都很慢。二、偶尔出现慢的情况1、数据库在刷新脏页 插入或更新一条数据的时候，数据库会在内存中把对应字段的数据更新。 更新后并不会马上同步持久化到磁盘。 先写入redo log日志，等空闲的时候通过redo log中的日志把最新的数据同步到磁盘。 redo log容量是有限的，如果数据库一直繁忙且更新又频繁，redo log很快就会被写满了。 等不到空闲再同步，只能暂停其他操作，全力同步数据到磁盘。 导致平时正常的SQL突然变慢。2、拿不到锁 执行的SQL语句涉及到的表被使用且加了锁，只能等待别人释放锁。 表没有加锁，但是要用到的某一行被加了锁，只能等待别人释放锁。 可以用show processlist命令来查看当前的状态。三、一直都很慢1、没用到索引 字段没有索引。 字段有索引，但没用到索引。 在字段的左边做了运算。 12select * from t where t.xx-1=8; #不走索引select * from t where t.xx=8+1; #走索引 函数操作导致没用到索引。1select * from t where mod(t.xx,2)=1; #不走索引 2、数据库选错索引1select * from t where 100&lt;t.xx and t.xx &lt; 10000; 主键索引和非主键索引有区别。 主键索引存放的值是整行字段的数据。 非主键索引存放的值是主键字段的值。 如果走t.xx这个字段的索引，最后会查询到对应主键的值，然后再根据主键的值走主键索引，查询整行数据返回。 系统执行这条语句的时候，会进行预测：看看是走字段索引扫描的行数少还是直接扫描全表扫描的行数少。 扫描行数越少，I/O次数越少，查询越快。 扫描全表的扫描次数就是这个表的总行数，假设为m。 走t.xx索引的话，通过索引找到主键，再通过主键来找数据，需要走2次索引。 假如全表的数据都符合100&lt;t.xx and t.xx &lt; 10000这个条件，意味着不仅扫描的行数是m，且每行数据还得走2次索引。 系统通过索引的区分度来判断。 一个索引上不同的值越多，意味着出现相同数值的索引越少，索引的区分度越高。 区分度也称之为基数。 基数越大意味着走索引越有优势。 系统通过采样的方式来预测索引的基数。 采样可能出现失误。 采样的那一部分数据刚好基数很小，误以为索引基数很小。 系统不走t.xx字段索引，走全表扫描。 系统判断是否走索引，扫描行数的预测只是原因之一，SQL语句是否使用临时表、是否需要排序等也会影响系统的选择。 强制走索引查询。123select * from t force index(a) where 100&lt;t.xx and t.xx &lt; 10000; show index from t; #查询索引的基数和实际是否符合analyze table t; #如果和实际很不符合，重新统计分析","tags":[{"name":"mysql","slug":"mysql","permalink":"http://127.0.0.1:4000/tags/mysql/"}]},{"title":"String中的intern","date":"2019-06-21T07:43:56.423Z","path":"2019/06/21/GoogleJava编程风格指南/","text":"String#intern 如果常量池中存在当前字符串，直接返回当前字符串。 如果常量池中没有，将此字符串放入常量池后，再返回。 intern是一个native方法。 jdk6123456789101112// jdk6String s2=new String(\"wj88\");s2.intern();String s1=\"wj88\";System.out.println(s1==s2);//falseSystem.out.println(s1==s2.intern());//true String s3=new String(\"wj88\")+new String(\"99\");s3.intern();String s4=\"wj8899\";System.out.println(s3==s4);//falseSystem.out.println(s3.intern()==s4);//true 123456789101112// jdk6String s2=new String(\"wj88\");String s1=\"wj88\";s2.intern();System.out.println(s1==s2);//falseSystem.out.println(s1==s2.intern());//true String s3=new String(\"wj88\")+new String(\"99\");String s4=\"wj8899\";s3.intern();System.out.println(s3==s4);//falseSystem.out.println(s3.intern()==s4);//true String s = new String(“wj88”)创建了2个对象,常量池中的wj88，堆中的String对象。 jdk6中的常量池是放在Perm区中，和堆区是完全分开的。 使用引号声明的字符串直接在常量池生成。 使用new的字符串放在堆区。 区域不同，引用自然也不同。 jdk7123456789101112// jdk7String s2=new String(\"wj88\");//代码 as2.intern();//代码 bString s1=\"wj88\";//代码 cSystem.out.println(s1==s2);//falseSystem.out.println(s1==s2.intern());//true 代码 d String s3=new String(\"wj88\")+new String(\"99\");//代码 es3.intern();//代码 fString s4=\"wj8899\";//代码 gSystem.out.println(s3==s4);//true System.out.println(s3.intern()==s4);//true 123456789101112// jdk7String s2=new String(\"wj88\");String s1=\"wj88\";s2.intern();System.out.println(s1==s2);//falseSystem.out.println(s1==s2.intern());//true String s3=new String(\"wj88\")+new String(\"99\");String s4=\"wj8899\";//代码 hs3.intern();//代码 kSystem.out.println(s3==s4);//falseSystem.out.println(s3.intern()==s4);//true jdk6之前 的版本，字符串常量池放在Perm区中，默认大小只有4M，大量使用intern会导致java.lang.OutOfMemoryError: PermGen space错误。jdk7中已经从Perm移到了堆中，jdk8取消了Perm，新建了一个元区域。 代码 a：生成常量池中的”wj88”,堆中的String对象。s2指向堆中的地址。 代码 b：s2区常量池中找发现已经存在”wj88”。返回常量池地址，所以代码d输出为true。 代码 c：直接将s1指向常量池中的”wj88”。s1与s2指向的地址不同，所以输出为false。 代码 e：生成常量池中的”wj88”，”99”，堆中的3个String对象。s3指向堆中wj8899对象的地址。此时常量池没有”wj8899”。 代码 f：将”wj8899”放入常量池。jdk7常量池做了调整，不需要再存储一份对象了，可以直接存储堆中的引用。所以和s3的引用是相同的。 代码 g：直接区常量池中找，发现已经存在直接返回，也就是s3的引用。所以s3==s4为true。 代码 h：执行的时候常量池不存在”wj8899”，所以生成一个对象返回引用地址。 代码 k：执行的时候常量池已经存在”wj8899”，所以s3和s4的地址是不同的。","tags":[{"name":"String","slug":"String","permalink":"http://127.0.0.1:4000/tags/String/"}]},{"title":"系统内存管理","date":"2019-06-20T09:43:24.000Z","path":"2019/06/20/系统内存管理/","text":"内存管理 CPU模式 实模式：直接通过物理地址访问内存。 保护模式：通过一个地址映射表把虚拟的内存地址转为物理的内存地址，然后再去读取数据。 操作系统根据CPU模式分为：实模式系统、保护模式系统。 实模式下内存管理 所以软件包括操作系统本身，工作在同一个物理地址，CPU认为它们是同一个程序。 操作系统分配内存方法： 把操作系统内存管理相关的函数地址，放到一个公共的地方，其他软件要申请内存就到这个地方获取内存管理函数并调用。 把内存管理功能设计为一个中断请求，内存全局有个中断向量表，本质也是在一个公共的地方放一些函数地址。 上述2个方法实质上一样，只是机制细节有些不同。 操作系统如何运行硬盘上的软件： 把软件从硬盘读到内存然后执行。 软件还没加载到内存的时候，不知自己会在哪里，所以很多涉及到数据、函数的地址没发固定(浮动地址)，所以要在加载到内存时来确定。 实质上就是一个程序被分成了多个片段，实现了程序片段的动态加载而已。 中断：CPU响应硬件事件的一个机制。当硬件发生了需要CPU处理的事情时就会触发一个中断。 中断机制除了响应硬件外也提供了指令允许软件触发中断(软中断)。可以约定某个中断为内存管理，操作系统在初始化时把内存管理函数写到中断向量表的这个地方。 保护模式下内存管理 实模式的2个问题： 安全性：系统和软件都运行在一起，相互可以随意修改对方数据等。 同时可运行的软件数量少：程序代码量大，存储空间需求大。 保护模式下，内存访问不直接通过物理地址，而是基于虚拟内存。 虚拟内存模式下，整个内存空间被分为很多个连续的内存页，每个内存页大小固定。 CPU访问某个虚拟内存地址中的数据时，先计算出要访问哪个内存页，然后在通过一个地址映射表，把虚拟内存地址转为物理内存地址，然后到物理内存地址读数据。 地址映射表是一个数组，下表是内存页页号，值是该内存页对应的物理内存首地址。 缺页：某个内存页对应的物理内存地址不存在，没发读取数据。 CPU会发起一个缺页的中断请求，这个请求会被操作系统接管。 操作系统会为这个内存页分配物理内存，并恢复这个内存页的数据。 如果没有空闲物理内存分配，会选择一个最久没被访问的内存页进行淘汰。 淘汰前会把这个内存页的数据保存，因为下次CPU访问这个被淘汰的内存页一样会缺页，那时操作系统还要去恢复数据。 通过这个虚拟内存机制，操作系统不需要一下把整个软件装进内存，而是通过缺页中断按需加载。多个软件同时运行的问题解决了。 操作系统如何给运行中的软件分配内存： 不需额外的机制，反正内存地址是虚拟的。 系统可以一开始就给软件分配很大的内存，如果不用，什么都不发生。 一旦使用某个内存页，通过缺页中断分配真正的物理内存给它。 虚拟内存和缺页机制，CPU很好的解决了操作系统和软件的配合关系。 运行中的软件就是进程，有自己的地址映射表。所以，虚拟地址并不是全局的，而是每个进程有独立的。 保护模式下，操作系统让每个软件感觉自己在独占整个计算机资源，独立的虚拟地址很好的实现了这点，看起来在独享内存资源。 实模式下浮动地址问题也解决了，软件不需要在加载的时候重新调整CPU指令操作地址。 内存是进程运行的基础资源，保持进程基础资源的独立性，是软件治理的最基础要求。这也是保护模式的名称的由来。","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://127.0.0.1:4000/tags/操作系统/"}]},{"title":"ZooKeeper基础","date":"2019-06-10T08:22:40.000Z","path":"2019/06/10/ZooKeeper基础/","text":"ZooKeeper基础 来自：Java3y（微信号：java3y） 什么是ZooKeeper ZooKeeper主要服务于分布式系统，可以用ZooKeeper来做：统一配置管理、统一命名服务、分布式锁、集群管理。 使用分布式系统就无法避免对节点管理的问题(需要实时感知节点的状态、对节点进行统一管理等等)，而由于这些问题处理起来可能相对麻烦和提高了系统的复杂性，ZooKeeper作为一个能够通用解决这些问题的中间件就应运而生了。 为什么ZooKeeper能干这么多？ZooKeeper的数据结构，跟Unix文件系统非常类似，可以看做是一颗树，每个节点叫做ZNode。每一个节点可以通过路径来标识，结构图如下： 那ZooKeeper这颗”树”有什么特点呢？？ZooKeeper的节点我们称之为Znode，Znode分为两种类型： 短暂/临时(Ephemeral)：当客户端和服务端断开连接后，所创建的Znode(节点)会自动删除 持久(Persistent)：当客户端和服务端断开连接后，所创建的Znode(节点)不会删除 ZooKeeper和Redis一样，也是C/S结构(分成客户端和服务端) 监听器常见的监听场景有以下两项： 监听Znode节点的数据变化 监听子节点的增减变化 通过监听+Znode节点(持久/短暂[临时])，ZooKeeper就可以玩出这么多花样了。 ZooKeeper是怎么做到的？1、统一配置管理有三个系统A、B、C，他们有三份配置，分别是ASystem.yml、BSystem.yml、CSystem.yml，然后，这三份配置又非常类似，很多的配置项几乎都一样。 此时，如果我们要改变其中一份配置项的信息，很可能其他两份都要改。并且，改变了配置项的信息很可能就要重启系统。 把ASystem.yml、BSystem.yml、CSystem.yml相同的配置项抽取出来成一份公用的配置common.yml，并且即便common.yml改了，也不需要系统A、B、C重启。 将common.yml这份配置放在ZooKeeper的Znode节点中，系统A、B、C监听着这个Znode节点有无变更，如果变更了，及时响应。 2、统一命名服务统一命名服务的理解其实跟域名一样，是我们为这某一部分的资源给它取一个名字，别人通过这个名字就可以拿到对应的资源。 有一个域名 www.java3y.com，但我这个域名下有多台机器： 192.168.1.1 192.168.1.2 192.168.1.3 192.168.1.4 别人访问 www.java3y.com 即可访问到我的机器，而不是通过IP去访问。 3、分布式锁系统A、B、C都去访问 /locks节点 访问的时候会创建带顺序号的临时/短暂(EPHEMERAL_SEQUENTIAL)节点，比如，系统A创建了id_000000节点，系统B创建了id_000002节点，系统C创建了id_000001节点。 接着，拿到 /locks节点下的所有子节点(id_000000,id_000001,id_000002)，判断自己创建的是不是最小的那个节点 如果是，则拿到锁。 释放锁：执行完操作后，把创建的节点给删掉。 如果不是，则监听比自己要小1的节点变化。 举个例子： 系统A拿到 /locks节点下的所有子节点，经过比较，发现自己(id_000000)，是所有子节点最小的。所以得到锁。 系统B拿到 /locks节点下的所有子节点，经过比较，发现自己(id_000002)，不是所有子节点最小的。所以监听比自己小1的节点id_000001的状态。 系统C拿到 /locks节点下的所有子节点，经过比较，发现自己(id_000001)，不是所有子节点最小的。所以监听比自己小1的节点id_000000的状态。 …… 等到系统A执行完操作以后，将自己创建的节点删除(id_000000)。通过监听，系统C发现id_000000节点已经删除了，发现自己已经是最小的节点了，于是顺利拿到锁。 ….系统B如上。 4、集群状态三个系统A、B、C为例，在ZooKeeper中创建临时节点即可： 只要系统A挂了，那 /groupMember/A这个节点就会删除，通过监听groupMember下的子节点，系统B和C就能够感知到系统A已经挂了。(新增也是同理) 除了能够感知节点的上下线变化，ZooKeeper还可以实现动态选举Master的功能。(如果集群是主从架构模式下) 原理也很简单，如果想要实现动态选举Master的功能，Znode节点的类型是带顺序号的临时节点(EPHEMERAL_SEQUENTIAL)就好了。 Zookeeper会每次选举最小编号的作为Master，如果Master挂了，自然对应的Znode节点就会删除。然后让新的最小编号作为Master，这样就可以实现动态选举的功能了。 最后ZooKeeper通过Znode的节点类型+监听机制就实现那么多好用的功能了！","tags":[{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"http://127.0.0.1:4000/tags/ZooKeeper/"}]},{"title":"centos7安装mysql5.7","date":"2019-06-05T02:52:42.000Z","path":"2019/06/05/centos7安装mysql5.7/","text":"centos7安装mysql5.71. 检查是否安装mysql。1rpm -qa | grep -i mysql 如果有，使用 [rpm -e –nodeps] 卸载 2. 检查是否安装mariadb。1rpm -qa | grep -i mariadb 如果有，使用 [rpm -e –nodeps] 卸载 3. 下载 mysql80-community-release-el7-3.noarch.rpm。4. 安装yum源。1yum -y install mysql80-community-release-el7-3.noarch.rpm 5. 根据需要开启mysql源。123456789101112131415vim /etc/yum.repos.d/mysql-community.repo[mysql80-community]name=MySQL 8.0 Community Serverbaseurl=http://repo.mysql.com/yum/mysql-8.0-community/el/7/$basearch/enabled=1gpgcheck=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql[mysql57-community]name=MySQL 5.7 Community Serverbaseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/7/$basearch/enabled=0gpgcheck=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql enabled=1是开启，=0是关闭，如果是centos6,需要将yum源里面baseurl改为/el/6/。 1234yum -y install yum-utils #开启 mysql57-community的yum源yum-config-manager --enable mysql57-community 6. 安装数据库。123yum repolist enabled | grep mysql #查看 开启的mysql源yum -y install mysql-community-server #安装 7. 启动。123456789101112131415systemctl start mysqld #centos7中运行服务的命令不在是server 服务名 start(restart stop status)，而是systemctl start 服务名cat /var/log/mysqld.log | more #查看初始密码mysql -uroot -pset global validate_password_policy=0; #密码复杂度属性set password=&apos;Pwd@123456&apos;; #修改初始密码grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;6789@jkl&apos;; #授权远程访问flush privileges; #刷新权限","tags":[{"name":"mysql","slug":"mysql","permalink":"http://127.0.0.1:4000/tags/mysql/"}]},{"title":"线程中断","date":"2019-05-24T05:25:43.000Z","path":"2019/05/24/线程中断/","text":"线程中断1、java.lang.Thread#interrupt 中断目标线程，给目标线程发一个中断信号，线程被打上中断标记。 2、java.lang.Thread#isInterrupted() 判断目标线程是否被中断，不会清除中断标记。 3、java.lang.Thread#interrupted123456789private static void test1() &#123; Thread thread = new Thread(() -&gt; &#123; while (true) &#123; Thread.yield(); &#125; &#125;); thread.start(); thread.interrupt();&#125; 虽然给线程发出了中断信号，但程序中并没有响应中断信号的逻辑，所以程序不会有任何反应。 123456789101112131415private static void test2() &#123; Thread thread = new Thread(() -&gt; &#123; while (true) &#123; Thread.yield(); // 响应中断 if (Thread.currentThread().isInterrupted()) &#123; System.out.println(\"线程被中断，程序退出。\"); return; &#125; &#125; &#125;); thread.start(); thread.interrupt();&#125; 加上了响应中断的逻辑，程序接收到中断信号打印出信息后返回退出。 1234567891011121314151617181920private static void test3() throws InterruptedException &#123; Thread thread = new Thread(() -&gt; &#123; while (true) &#123; // 响应中断 if (Thread.currentThread().isInterrupted()) &#123; System.out.println(\"线程被中断，程序退出。\"); return; &#125; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; System.out.println(\"线程休眠被中断，程序退出。\"); &#125; &#125; &#125;); thread.start(); Thread.sleep(2000); thread.interrupt();&#125; sleep() 方法被中断，并输出了 线程休眠被中断，程序退出。 程序继续运行……为什么呢？ sleep() 方法被中断后会清除中断标记，所以循环会继续运行。 123456789101112131415161718192021private static void test4() throws InterruptedException &#123; Thread thread = new Thread(() -&gt; &#123; while (true) &#123; // 响应中断 if (Thread.currentThread().isInterrupted()) &#123; System.out.println(\"线程被中断，程序退出。\"); return; &#125; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; System.out.println(\"线程休眠被中断，程序退出。\"); Thread.currentThread().interrupt(); &#125; &#125; &#125;); thread.start(); Thread.sleep(2000); thread.interrupt();&#125; 全部信息输出并正常退出，只是在 sleep() 方法被中断并清除标记后手动重新中断当前线程，然后程序接收中断信号返回退出。","tags":[{"name":"线程","slug":"线程","permalink":"http://127.0.0.1:4000/tags/线程/"}]},{"title":"jQuery入门","date":"2019-05-13T03:03:06.000Z","path":"2019/05/13/jQuery入门/","text":"jQuery[^1]: jQuery 选择器[^2]: jQuery 事件方法[^3]: jQuery 遍历方法 语法通过选取 HTML 元素，并对选取的元素执行某些操作。 基础： $(selector).action() $ 定义 jQuery selector “查询”和”查找” HTML 元素 action() 执行对元素的操作 文档就绪事件防止文档在完全加载（就绪）之前运行 jQuery 代码。 123456789$(document).ready(function()&#123; // 开始写 jQuery 代码...&#125;);// 简洁写法$(function()&#123; // 开始写 jQuery 代码...&#125;); 选择器 selector[^1] 所有选择器都以美元符号开头： $(...) 选取所有元素： $(“*”) 选取当前 HTML 元素： $(this) 选取所有 tag 元素： $(“tag“) 选取带有 attr 属性的元素： $(“[attr]”) 选取所有 attr=”value“ 的 tag 元素： $(“tag[attr=’value‘]”) 选取所有 id=”id“ 的 &lt;tag&gt; 元素： $(“#id“) 选取所有带有 class=”class“ 属性的元素： $(“.class“) 选取所有 type=”type“ 的元素:： $(“:type“) 选取第一个 tag 元素： $(“tag:first”) 选取偶数位置的 tag 元素： $(“tag:even”) 选取奇数位置的 tag 元素： $(“tag:odd”) tag 元素的直接子元素的所有 child 元素： $(“tag &gt; child“) tag 元素的后代的所有 descendant 元素： $(“tag descendant“) 每个 tag 元素相邻的下一个 next 元素： $(“tag + next“) tag 元素同级的所有 siblings 元素： $(“tag ~ siblings“) 注意 各选择器可拼接 事件 event事件：页面对不同访问者的响应。 事件处理程序：当 HTML 中发生某些事件时所调用的方法。 常见 DOM 事件： 鼠标事件 click dblclick mouseenter mouseleave 键盘事件 keypress keydown keyup 表单事件 submit change focus blur 文档/窗口事件 load resize scroll unload 事件方法语法指定一个点击事件： $(selector).click(); 常用[^2] $(document).ready() click()：单击元素 dblclick()：双击元素 mouseenter()：鼠标指针穿过元素 mouseleave()：鼠标指针离开元素 mousedown()：鼠标指针移动到元素上方并按下鼠标按键 mouseup()：在元素上松开鼠标按钮 hover()：模拟光标悬停事件 当鼠标移动到元素上时，会触发指定的第一个函数(mouseenter)；当鼠标移出这个元素时，会触发指定的第二个函数(mouseleave)。 focus()：元素获得焦点 鼠标点击选中元素或通过 tab 键定位到元素 blur()：元素失去焦点 keydown()：按下一个按键时发生，一直按着则会不断触发（opera浏览器除外），返回键盘代码 keypress()：按下一个按键并产生一个字符时发生，一直按着某按键则会不断触发，返回ASCII码 注意 shift、alt、ctrl等键按下并不会产生字符，所以监听无效。只有按下能在屏幕上输出字符的按键时keypress事件才会触发。 keyup()：松开某一个按键时触发，返回键盘代码 历遍[^3]了解 DOM 树 祖先 = 向上遍历 parent() 返回被选元素的直接父元素。 $(selector).parent(filter) parents() 返回被选元素的所有祖先元素，一路向上直到文档的根元素 (&lt;html&gt;)。 $(selector).parents(filter) parentsUntil() 返回介于两个给定元素之间的所有祖先元素。 $(selector).parentsUntil(stop, filter) 后代 = 向下遍历 children() 返回被选元素的所有直接子元素。 $(selector).children(filter) find() 返回被选元素的所有后代元素，一路向下直到最后一个后代。 $(selector).find(filter) 同胞 siblings（拥有相同的父元素） = 水平遍历 siblings() 方法返回被选元素的所有同胞元素。 $(selector).siblings(filter) next() 返回被选元素的后一个同胞元素。 $(selector).next(filter) prev() 用法相同，返回上一个 nextAll() 返回被选元素之后的所有同胞元素。 $(selector).nextAll(filter) prevAll() 用法相同，返回之前 nextUntil() 返回 selector 与 stop 之间的每个元素之后的所有同级元素。 $(selector).nextUntil(stop, filter) prevUntil() 用法相同，返回之前 过滤 first() 返回被选元素的第一个元素。 $(selector).first() last() 返回被选元素的最后一个元素。 $(selector).last() eq() 返回带有被选元素的指定索引号的元素。 $(selector).eq(index) 注意 索引号从 0 开头； 负数从被选元素的结尾返回。 filter() 返回符合条件的元素。 $(selector).filter(criteria, function(index)) not() 返回不符合条件的元素。 $(selector).not(criteria, function(index))","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://127.0.0.1:4000/tags/jQuery/"}]},{"title":"git常用命令","date":"2019-05-13T03:03:06.000Z","path":"2019/05/13/git常用命令/","text":"git常用命令 设置提交代码时的用户信息 $ git config user.name “name“ $ git config user.email “email“ 在当前目录新建一个仓库 $ git init 下载一个仓库 $ git clone url 添加当前目录的所有变化文件到暂存区 $ git add . 取消添加 $ git reset HEAD &lt;filename&gt; 提交到仓库区 $ git commit 提交暂存区到仓库区 $ git commit -am [message] 修改最后一次提交的信息 $ git commit –amend -m 替换的message 列出本地分支 $ git branch 列出远端分支 $ git branch -r 列出所有分支 $ git branch -a 查看当前详细分支信息（可看到当前分支与对应的远程追踪分支） $ git branch -vv 新建一个名为 branch-name 的分支，但依然停留在当前分支 $ git branch branch-name 重命名当前[old-branch-name]分支 $ git branch -m [old-branch-name] new-branch-name 重命名远程[origin/old-branch-name]分支 $ git push origin –d old-branch-name 切换到 branch-name 分支，并更新工作区 $ git checkout branch-name 新建并切换到 branch-name 分支 $ git checkout -b branch-name 切换到上一个分支 $ git checkout - 新建并切换到连接到指定远程分支的 branch 分支 $ git checkout origin/branch -b branch 关联指定本地分支与指定远程分支 $ git branch –set-upstream-to=origin/remote_branch local_branch 新建当前分支的远程分支 git push origin new_branch 删除分支 只能删除已经被合并的分支 $ git branch -d branch-name 强制删除 $ git branch -D branch-name 删除远程分支 $ git push origin –delete branch-name 删除本地的远程分支 $ git branch -r -D origin/branch-name 变基 $ git rebase [branch] 合并 branch 分支到当前分支 $ git merge [branch] 显示有变更的文件 $ git status 显示当前分支的版本历史 $ git log 显示 commit 历史，以及每次 commit 发生变更的文件 $ git log –stat 搜索提交历史，根据关键词 $ git log -S keyword 显示当前分支的最近几次操作 $ git reflog 显示指定文件是谁、何时修改过 $ git blame [file] 显示暂存区和工作区的差异 $ git diff 显示工作区与当前分支最新 commit 之间的差异 $ git diff HEAD 显示两次个分支之间的差异（显示文件内容） $ git diff first-branch second-branch 显示所有远程仓库 $ git remote -v 查看当前远程仓库信息 $ git remote -vv 下载远程仓库的所有变动 $ git fetch [remote] 移除所有在远端已经被删除的远程分支 $ git fetch -p 上传本地 branch 分支到远程 remote 仓库 $ git push remote branch 重置 reset $ git reset [–mode] [commit] [file] mode soft：重置暂存区与工作区[的 file]，[与指定 commit 保持一致]，回退点之前的所有信息都在，只是没显示。 mixed：默认，重置暂存区[的 file]，[与指定 commit 保持一致]，工作区不变。 hard：重置暂存区与工作区[的 file]，[与指定 commit 保持一致]，回退点之前的所有信息都删掉。 储藏所有变更 $ git stash -a 储藏所有变更（带备注） $ git stash -a save ‘message‘ 查看现有的储藏 $ git stash list 恢复最近一次储藏，存储仍在栈上 $ git stash apply 恢复指定储藏，存储仍在栈上 $ git stash apply stash@{num} 删除指定储藏 $ git stash drop stash@{num} 删除所有储藏 $ git stash clear 恢复并删除栈上指定储藏 $ git stash pop stash@{num} 查看当前仓库中的所有未打包的objects和磁盘占用 $ git count-objects –human-readable 从object数据库中删除所有不可达的object $ git gc –prune=now –aggressive","tags":[{"name":"git","slug":"git","permalink":"http://127.0.0.1:4000/tags/git/"}]},{"title":"单点登录","date":"2019-05-13T02:48:05.000Z","path":"2019/05/13/单点登录/","text":"CAS实现SSO单点登录原理1. CAS简介1.1. What is CAS？CAS（Central Authentication Service） 是 Yale大学发起的一个企业级的、开源的项目，旨在为 Web 应用系统提供一种可靠的单点登录解决方法（属于Web SSO）。 CAS开始于2001年， 并在 2004年 12月正式成为JA-SIG的一个项目。 1.2. 主要特性1、 开源的、多协议的SSO解决方案；Protocols：Custom Protocol、CAS、OAuth、OpenID、RESTful API、SAML1.1、SAML2.0等。 2、 支持多种认证机制：Active Directory、JAAS、JDBC、LDAP、X.509 Certificates等； 3、 安全策略：使用票据（Ticket）来实现支持的认证协议； 4、 支持授权：可以决定哪些服务可以请求和验证服务票据（Service Ticket）； 5、 提供高可用性：通过把认证过的状态数据存储在TicketRegistry组件中，这些组件有很多支持分布式环境的实现，如：BerkleyDB、Default 、EhcacheTicketRegistry、JDBCTicketRegistry、JBOSS TreeCache、JpaTicketRegistry、MemcacheTicketRegistry等； 6、 支持多种客户端： Java、 .Net、 PHP、 Perl、 Apache, uPortal等。 2. SSO单点登录原理本文内容主要针对Web SSO。 2.1. 什么是SSO单点登录（Single Sign-On ,简称SSO）是目前比较流行的服务于企业业务整合的解决方案之一，SSO 使得在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。 2.2. SSO原理2.2.1. SSO体系中的角色一般SSO体系主要角色有三种： 1、 User（多个） 2、 Web应用（多个） 3、 SSO认证中心（1个） 2.2.2. SSO实现模式的原则SSO实现模式一般包括以下三个原则： 1、 所有的认证登录都在SSO认证中心进行； 2、 SSO认证中心通过一些方法来告诉 Web 应用当前访问用户究竟是不是已通过认证的用户； 3、 SSO 认证中心和所有的 Web 应用建立一种信任关系，也就是说web应用必须信任认证中心。（单点信任） 2.2.3. SSO主要实现方式SSO的主要实现方式有： 1、 共享cookies 基于共享同域的cookie是Web刚开始阶段时使用的一种方式，它利用浏览同域名之间自动传递cookies机制，实现两个域名之间系统令牌传递问题；另外，关于跨域问题，虽然cookies本身不跨域，但可以利用它实现跨域的SSO。如：代理、暴露SSO令牌值等。 缺点：不灵活而且有不少安全隐患，已经被抛弃。 2、 Broker-based(基于经纪人) 这种技术的特点就是，有一个集中的认证和用户帐号管理的服务器。经纪人给被用于进一步请求的电子身份存取。中央数据库的使用减少了管理的代价，并为认证提供一个公共和独立的”第三方”。例如Kerberos、Sesame、IBM KryptoKnight（凭证库思想)等。Kerberos是由麻省理工大学发明的安全认证服务，已经被UNIX和Windows作为默认的安全认证服务集成进操作系统。 3、 Agent-based（基于代理人） 在这种解决方案中，有一个自动地为不同的应用程序认证用户身份的代理程序。这个代理程序需要设计有不同的功能。比如，它可以使用口令表或加密密钥来自动地将认证的负担从用户移开。代理人被放在服务器上面，在服务器的认证系统和客户端认证方法之间充当一个”翻译”。例如SSH等。 4、 Token-based 例如SecureID,WebID，现在被广泛使用的口令认证，比如FTP、邮件服务器的登录认证，这是一种简单易用的方式，实现一个口令在多种应用当中使用。 5、 基于网关 6、 基于SAML SAML(Security Assertion Markup Language，安全断言标记语言）的出现大大简化了SSO，并被OASIS批准为SSO的执行标准。开源组织OpenSAML 实现了 SAML 规范。 3. CAS的基本原理3.1. 结构体系从结构体系看，CAS包括两部分：CAS Server和CAS Client。 3.1.1. CAS ServerCAS Server负责完成对用户的认证工作, 需要独立部署, CAS Server 会处理用户名 / 密码等凭证 (Credentials)。 3.1.2. CAS Client负责处理对客户端受保护资源的访问请求，需要对请求方进行身份认证时，重定向到CAS Server进行认证。（原则上，客户端应用不再接受任何的用户名密码等 Credentials）。 CAS Client 与受保护的客户端应用部署在一起，以 Filter 方式保护受保护的资源。 3.2. CAS原理和协议3.2.1. 基础模式基础模式SSO访问流程主要有以下步骤： 访问服务：SSO客户端发送请求访问应用系统提供的服务资源。 定向认证：SSO客户端会重定向用户请求到SSO服务器。 用户认证：用户身份认证。 发放票据：SSO服务器会产生一个随机的Service Ticket。 验证票据：SSO服务器验证票据Service Ticket的合法性，验证通过后，允许客户端访问服务。 传输用户信息：SSO服务器验证票据通过后，传输用户认证结果信息给客户端。 下面是CAS 最基本的协议过程： 基础协议图 如上图：CAS Client 与受保护的客户端应用部署在一起，以Filter方式保护Web应用的受保护资源，过滤从客户端过来的每一个Web请求，同时，CAS Client 会分析HTTP请求中是否包含请求Service Ticket( ST上图中的Ticket) ，如果没有，则说明该用户是没有经过认证的；于是CAS Client 会重定向用户请求到 CAS Server（Step 2），并传递Service（要访问的目的资源地址）。 Step 3是用户认证过程，如果用户提供了正确的Credentials， CAS Server随机产生一个相当长度、唯一、不可伪造的Service Ticket，并缓存以待将来验证，并且重定向用户到Service 所在地址（附带刚才产生的Service Ticket ）, 并为客户端浏览器设置一个Ticket Granted Cookie（TGC）；CAS Client 在拿到Service和新产生的 Ticket过后，在Step 5和Step6中与CAS Server进行身份核实，以确保 Service Ticket 的合法性。 在该协议中，所有与CAS Server的交互均采用SSL协议，以确保ST和TGC的安全性。协议工作过程中会有2次重定向的过程。但是 CAS Client与CAS Server之间进行Ticket验证的过程对于用户是透明的（使用HttpsURLConnection）。 ​ CAS请求认证时序图如下： 3.2.1. CAS 如何实现 SSO当用户访问另一个应用的服务再次被重定向到CAS Server的时候，CAS Server会主动获到这个TGC cookie，然后做下面的事情： 1) 如果User持有TGC且其还没失效，那么就走基础协议图的Step4，达到了 SSO 的效果； 2) 如果TGC失效，那么用户还是要重新认证 (走基础协议图的Step3)。 3.2.2. CAS代理模式该模式形式为用户访问App1，App1又依赖于App2来获取一些信息，如：User –&gt;App1 –&gt;App2 。 这种情况下，假设App2也是需要对User进行身份验证才能访问，那么，为了不影响用户体验（过多的重定向导致User的IE窗口不停地闪动)，CAS引入了一种Proxy认证机制，即CAS Client可以代理用户去访问其它Web应用。 代理的前提是需要CAS Client拥有用户的身份信息(类似凭据)。之前我们提到的TGC是用户持有对自己身份信息的一种凭据，这里的PGT就是CAS Client端持有的对用户身份信息的一种凭据。凭借TGC，User可以免去输入密码以获取访问其它服务的Service Ticket，所以，这里凭借PGT，Web应用可以代理用户去实现后端的认证，而无需前端用户的参与。 下面为代理应用（helloService）获取PGT的过程：（注：PGTURL用于表示一个Proxy服务，是一个回调链接；PGT相当于代理证；PGTIOU为取代理证的钥匙，用来与PGT做关联关系；） 如上面的CAS Proxy图所示，CAS Client 在基础协议之上，在验证ST时提供了一个额外的PGT URL(而且是 SSL 的入口)给CAS Server，使得CAS Server可以通过PGT URL提供一个PGT给CAS Client。 CAS Client拿到了PGT(PGTIOU-85…..ti2td)，就可以通过PGT向后端Web应用进行认证。 下面是代理认证和提供服务的过程： 如上图所示，Proxy认证与普通的认证其实差别不大，Step1，2与基础模式的Step1,2几乎一样，唯一不同的是，Proxy模式用的是PGT而不是TGC，是Proxy Ticket（PT）而不是Service Ticket。 3.2.3. 辅助说明CAS的SSO实现方式可简化理解为：1个Cookie和N个Session。CAS Server创建cookie，在所有应用认证时使用，各应用通过创建各自的Session来标识用户是否已登录。 用户在一个应用验证通过后，以后用户在同一浏览器里访问此应用时，客户端应用中的过滤器会在session里读取到用户信息，所以就不会去CAS Server认证。如果在此浏览器里访问别的web应用时，客户端应用中的过滤器在session里读取不到用户信息，就会去CAS Server的login接口认证，但这时CAS Server会读取到浏览器传来的cookie（TGC），所以CAS Server不会要求用户去登录页面登录，只是会根据service参数生成一个Ticket，然后再和web应用做一个验证ticket的交互而已。 3.3. 术语解释CAS系统中设计了5中票据：TGC、ST、PGT、PGTIOU、PT。 Ø Ticket-granting cookie(TGC)：存放用户身份认证凭证的cookie，在浏览器和CAS Server间通讯时使用，并且只能基于安全通道传输（Https），是CAS Server用来明确用户身份的凭证； Ø Service ticket(ST)：服务票据，服务的惟一标识码,由CAS Server发出（Http传送），通过客户端浏览器到达业务服务器端；一个特定的服务只能有一个惟一的ST； Ø Proxy-Granting ticket（PGT）：由CAS Server颁发给拥有ST凭证的服务，PGT绑定一个用户的特定服务，使其拥有向CAS Server申请，获得PT的能力； Ø Proxy-Granting Ticket I Owe You（PGTIOU）:作用是将通过凭证校验时的应答信息由CAS Server 返回给CAS Client，同时，与该PGTIOU对应的PGT将通过回调链接传给Web应用。Web应用负责维护PGTIOU与PGT之间映射关系的内容表； Ø Proxy Ticket (PT)：是应用程序代理用户身份对目标程序进行访问的凭证； 其它说明如下： Ø Ticket Granting ticket(TGT)：票据授权票据，由KDC的AS发放。即获取这样一张票据后，以后申请各种其他服务票据(ST)便不必再向KDC提交身份认证信息(Credentials)； Ø Authentication service(AS) ———认证用服务，索取Credentials，发放TGT； Ø Ticket-granting service (TGS) ———票据授权服务，索取TGT，发放ST； Ø KDC( Key Distribution Center ) ———-密钥发放中心； 4. CAS安全性CAS的安全性仅仅依赖于SSL。使用的是secure cookie。 4.1. TGC/PGT安全性对于一个 CAS 用户来说，最重要是要保护它的TGC，如果TGC不慎被CAS Server以外的实体获得，Hacker能够找到该TGC，然后冒充CAS用户访问所有授权资源。PGT的角色跟TGC是一样的。 从基础模式可以看出， TGC是CAS Server通过SSL方式发送给终端用户，因此，要截取TGC难度非常大，从而确保CAS的安全性。 TGT的存活周期默认为120分钟。 4.2. ST/PT安全性ST（Service Ticket）是通过Http传送的，因此网络中的其他人可以Sniffer到其他人的Ticket。CAS通过以下几方面来使ST变得更加安全（事实上都是可以配置的）： 1、 ST只能使用一次 CAS协议规定，无论 Service Ticket验证是否成功， CAS Server都会清除服务端缓存中的该Ticket，从而可以确保一个Service Ticket不被使用两次。 2、 ST在一段时间内失效 CAS规定ST只能存活一定的时间，然后CAS Server会让它失效。默认有效时间为5分钟。 3、 ST是基于随机数生成的 ST必须足够随机，如果ST生成规则被猜出，Hacker就等于绕过CAS认证，直接访问对应的服务。 集成方式filter方式MAVEN 12345&lt;dependency&gt; &lt;groupid&gt;org.jasig.cas.client&lt;/groupid&gt; &lt;artifactid&gt;cas-client-core&lt;/artifactid&gt; &lt;version&gt;3.1.12&lt;/version&gt;&lt;/dependency&gt; web.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;!-- 用于单点退出，该过滤器用于实现单点登出功能，可选配置--&gt;&lt;listener&gt; &lt;listener-class&gt; org.jasig.cas.client.session.SingleSignOutHttpSessionListener &lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 该过滤器用于实现单点登出功能，可选配置。 --&gt;&lt;filter&gt; &lt;filter-name&gt;CAS Single Sign Out Filter&lt;/filter-name&gt; &lt;filter-class&gt; org.jasig.cas.client.session.SingleSignOutFilter &lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CAS Single Sign Out Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; &lt;!-- 该过滤器负责用户的认证工作，必须启用它 --&gt;&lt;filter&gt; &lt;filter-name&gt;CASFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.jasig.cas.client.authentication.AuthenticationFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerLoginUrl&lt;/param-name&gt; &lt;param-value&gt;https://sso.wsria.com:8443/cas/login&lt;/param-value&gt; &lt;!--这里的server是服务端的IP--&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;http://localhost:10000&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CASFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; &lt;!-- 该过滤器负责对Ticket的校验工作，必须启用它 --&gt;&lt;filter&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerUrlPrefix&lt;/param-name&gt; &lt;param-value&gt;https://sso.wsria.com:8443/cas&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;http://localhost:10000&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;!--该过滤器负责实现HttpServletRequest请求的包裹，比如允许开发者通过HttpServletRequest的getRemoteUser()方法获得SSO登录用户的登录名，可选配置。--&gt;&lt;filter&gt; &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt; &lt;filter-class&gt; org.jasig.cas.client.util.HttpServletRequestWrapperFilter &lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;!--该过滤器使得开发者可以通过org.jasig.cas.client.util.AssertionHolder来获取用户的登录名。比如AssertionHolder.getAssertion().getPrincipal().getName()。--&gt;&lt;filter&gt; &lt;filter-name&gt;CAS Assertion Thread Local Filter&lt;/filter-name&gt; &lt;filter-class&gt; org.jasig.cas.client.util.AssertionThreadLocalFilter &lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CAS Assertion Thread Local Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;!-- 自动根据单点登录的结果设置本系统的用户信息 --&gt;&lt;filter&gt; &lt;display-name&gt;AutoSetUserAdapterFilter&lt;/display-name&gt; &lt;filter-name&gt;AutoSetUserAdapterFilter&lt;/filter-name&gt; &lt;filter-class&gt; com.wsria.demo.filter.AutoSetUserAdapterFilter &lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;AutoSetUserAdapterFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;!-- ======================== 单点登录结束 ======================== --&gt;","tags":[{"name":"单点登录","slug":"单点登录","permalink":"http://127.0.0.1:4000/tags/单点登录/"}]},{"title":"正则表达式","date":"2019-05-10T05:16:25.000Z","path":"2019/05/10/正则表达式/","text":"基本字符1.限定符 *: 零次或多次{0,} +:一次或多次{1,} ?:零次或一次{0,1} {n}:n是一个非负整数。匹配确定的n次 {n,}:n是一个非负整数。至少匹配n次 {n,m}:最少匹配n次且最多匹配m次 2.模式 贪婪模式和非贪婪模式 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o” 3.特殊字符 $:匹配输入字符串的结尾位置 .:匹配除换行符 \\n 之外的任何单字符 ():标记一个子表达式的开始和结束位置。（分组） [:标记一个中括号表达式的开始。（字符簇） {:标记限定符表达式的开始（限定符） ^:匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合（[^a-z]） |:指明两项之间的一个选择 :将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“ 4.定位符 ^:匹配输入字符串开始的位置 $:匹配输入字符串结尾的位置 \\b:匹配一个字边界，即字与空格间的位置。(边界运算) \\B:非字边界匹配。（非边界运算） 不能将限定符与定位符一起使用。由于在紧靠换行或者字边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式 5.字符簇 [a-z] //匹配所有的小写字母 [A-Z] //匹配所有的大写字母 [a-zA-Z] //匹配所有的字母 [0-9] //匹配所有的数字 [0-9.-] //匹配所有的数字，句号和减号 [ \\f\\r\\t\\n] //匹配所有的白字符 运算 分组反向引用先来看第一个作用，对于IP地址的匹配，简单的可以写为如下形式：\\d{1,3}.\\d{1,3}.\\d{1,3}.\\d{1,3}我们可以发现一定的规律，可以把.\\d{1,3}看成一个整体，也就是把他们看成一组，再把这个组重复3次即可。表达式如下：\\d{1,3}(.\\d{1,3}){3} 再来看第二个作用，就拿匹配xxx标签来说，简单的正则可以这样写：.*可以看出，上边表达式中有两个title，完全一样，其实可以通过分组简写。表达式如下&lt;(title)&gt;.*&lt;/\\1&gt; 断言指明某个字符串前边或者后边，将会出现满足某种规律的字符串 后发断言(?&lt;= 和 ?&lt;!) 先行断言(?= 和 ?!) 区分正反（即是否满足条件&lt;=(满足)&lt;!（不满足））就拿匹配xxx标签来说，我们想要的是xxx，它没有规律，但是它前边肯定会有，后边肯定会有，这就足够了。想指定xxx前肯定会出现，就用正后发断言，表达式：(?&lt;=).* 想指定xxx后边肯定会出现，就用正先行断言，表达式：.(?=) 两个加在一起，就是(?&lt;=).(?=)","tags":[{"name":"java","slug":"java","permalink":"http://127.0.0.1:4000/tags/java/"}]},{"title":"编码规范及其数据库设计规范","date":"2019-05-10T01:02:25.000Z","path":"2019/05/10/编码规范及其数据库设计规范/","text":"命名规范不能以下划线或美元符号开始和结束。常量名全部大写，单词间用下划线隔开，语义表达完整清楚，不要嫌名字长。 1.包名包名应当使用有意义的英文名或英文名缩写。统一小写。公司包名称应当以com.thunisoft开头。 2.类名，方法名使用有意义的英文名或英文名缩写、中文全拼或中文简拼缩写。建议使用英文命名。如果是多个关键词组成，应当使用驼峰命名法。使用长的完整类名。抽象类应当使用Abstract或Base开头。异常类使用Exception结尾。接口实现类应当以Impl结尾。类名首字母大写，方法名小写。 3.接口继承性的接口应当以I开头，I后面的第一个字母大写。接口类中的方法和属性不要加任何修饰符号（public 也不要加） ，保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。 实现类用 Impl 的后缀与接口区别。 4.成员变量名成员变量如果是类类型，建议命名时与对应的类名近似。UserInfo userInfo 5.方法参数名如果是类类型，建议命名与对应的类名近似。方法参数建议不超过3个。方法参数禁止超过5个，POJO的构造函数除外。 6.临时变量名临时变量应当具有业务涵义建议临时变量使用类型前缀或后缀 类型前缀如下：| 基本类型 | 类类型 | 前缀/后缀 || ———— | :——————–: | —-: || int | java.lang.Integer | i || float | java.lang.Float | f || double | java.lang.Double | d || boolean | java.lang.Boolean | b || short | java.lang.Shot | sh || long | java.lang.Long | l || date | java.util.Date | dt || string | java.lang.String | s || StringBuffer | java.lang.StringBuffer | sb || file | java.io.File | file || list | java.util.List | list || 数组 | - | ary || map | java.util.Map | map | 7.文件夹样式相关文件，如css，img，样式相关的js文件应当保存在同一个文件夹下。 8.文件名jsp文件名应当以小写字母开头。Jsp文件名建议与对应的请求action名一致。 css文件名应当进行归类。如布局相关的可叫做layout.css。导航栏的可以叫navigation.css。等。 js文件名应当有意义。index.js bar.js Spring的配置文件应当以spring-开头Struts的配置文件应当以struts-开头数据库配置database.properties配置文件config.properties 9.注释类注释应当包括：作者、创建日期、版本、类描述、修改记录。 抽象类：描述实现着需要关注的东西。 实现类：类的主要功能。 继承性接口：描述实现者需要特别关注的东西。 一般接口：描述接口的主要功能。 一般方法：描述方法的主要功能，参数涵义，返回值涵义。 成员变量：描述成员变量的涵义。 重要算法注释：描述算法的思路。 类、类属性、类方法的注释必须使用 Javadoc 规范，使用/*内容/格式，不得使用// xxx 方式。 所有的抽象方法（包括接口中的方法） 必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。 所有的类都必须添加创建者和创建日期。 方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/* */注释，注意与代码对齐。 代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。 10.数组类型与中括号紧挨相连来表示数组。int[] arrayDemo; 11.如果模块、 接口、类、方法使用了设计模式，在命名时需体现出具体模式。有利于阅读者快速理解架构设计理念。public class OrderFactory;public class LoginProxy;public class ResourceObserver; 12.不允许任何魔法值（即未经预先定义的常量） 直接出现在代码中。for(int i=0;i&lt;4;i++){***} 13.在 long 或者 Long 赋值时， 数值后使用大写的 L。Long a = 2l; 写的是数字的 21，还是 Long 型的 2? 代码1.大括号左大括号前不换行。左大括号后换行。右大括号前换行。右大括号后还有 else 等代码则不换行。 2.if/for/while/switch/do 等保留字与括号之间都必须加空格。3.任何二目、 三目运算符的左右两边都需要加一个空格。运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号等。 4.采用 4 个空格缩进，禁止使用 tab 字符。如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。 IDEA 设置 tab 为 4 个空格时，请勿勾选 Use tab character；而在 eclipse 中，必须勾选 insert spaces for tabs。 123456789101112131415161718public static void main(String[] args) &#123; // 缩进 4 个空格 String say = \"hello\"; // 运算符的左右必须有一个空格 int flag = 0; // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号， 0 与右括号不需要空格 if (flag == 0) &#123; System.out.println(say); &#125; // 左大括号前加空格且不换行；左大括号后换行 if (flag == 1) &#123; System.out.println(\"world\"); // 右大括号前换行，右大括号后有 else，不用换行 &#125; else &#123; System.out.println(\"ok\"); // 在右大括号后直接结束，则必须换行 &#125;&#125; 5.注释的双斜线与注释内容之间有且仅有一个空格。// 这是示例注释，请注意在双斜线之后有一个空格String ygb = new String(); 6.IDE 的 text file encoding 设置为 UTF-8; IDE 的换行符使用 Unix 格式，不要使用 Windows 格式。7.Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。“test”.equals(object); java.util.Objects#equals（JDK7 引入的工具类） 8.所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。对于 Integer var = ? 在-128 至 127 范围内的赋值， Integer 对象是在IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。 9.类成员与方法访问控制从严。1） 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。2） 工具类不允许有 public 或 default 构造方法。3） 类非 static 成员变量并且与子类共享，必须是 protected。4） 类非 static 成员变量并且仅在本类使用，必须是 private。5） 类 static 成员变量如果仅在本类使用，必须是 private。6） 若是 static 成员变量， 考虑是否为 final。7） 类成员方法只供类内部调用，必须是 private。8） 类成员方法只对继承类公开，那么限制为 protected。 过于宽泛的访问范围，不利于模块解耦。如果是一个 private 的方法，想删除就删除，可是一个 public 的 service 成员方法或成员变量，删除一下，呵呵~~ 10.ArrayList的subList结果不可强转ArrayList(ClassCastException)。subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList。 11.不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁。 12345678910List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"1\");list.add(\"2\");Iterator&lt;String&gt; iterator = list.iterator();while (iterator.hasNext()) &#123; String item = iterator.next(); if (删除元素的条件) &#123; iterator.remove(); &#125;&#125; 12.集合初始化时， 指定集合初始值大小。HashMap 使用 HashMap(int initialCapacity) 初始化。initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loaderfactor） 默认为 0.75。(即当 元素个数 超过 容量长度的0.75倍 时，进行扩容)如果暂时无法确定初始值大小，请设置为 16（即默认值） 。 13.使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。 14.Map 类集合 K/V 能不能存储 null 值的情况。 集合类 Key Value Super 说明 Hashtable 不允许为 null 不允许为 null Dictionary 线程安全 ConcurrentHashMap 不允许为 null 不允许为 null AbstractMap 锁分段技术 TreeMap 不允许为 null 允许为 null AbstractMap 线程不安全 HashMap 允许为 null 允许为 null AbstractMap 线程不安全 15.创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。public class TimerTaskThread extends Thread { public TimerTaskThread() { super.setName(“TimerTaskThread”); … }} 16.对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。线程一需要对表 A、 B、 C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、 B、 C，否则可能出现死锁。 17.在 if/else/for/while/do 语句中必须使用大括号。即使只有一行代码，避免采用单行的编码方式： if (condition) statements。 数据库1.表名、字段名必须使用小写字母或数字， 禁止出现数字开头，禁止两个下划线中间只出现数字。2.主键索引名为 pk_字段名； 唯一索引名为 uk_字段名； 普通索引名则为 idx_字段名。3.小数类型为 decimal，禁止使用 float 和 double。float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。 4.如果存储的字符串长度几乎相等，使用 char 定长字符串类型。5.varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。 6.表必备三字段： id, gmt_create, gmt_modified。7.不要使用 count(列名)或 count(常量)来替代 count(*)count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。 8.当某一列的值全是 NULL 时， count(col)的返回结果为 0，但 sum(col)的返回结果为NULL，因此使用 sum()时需注意 NPE 问题。可以使用如下方式来避免 sum 的 NPE 问题： SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table; 9.禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。10.数据库命名与应用名称相同。11.表命名T_ZJ_SCDB – 表_侦监_审查逮捕T_ZJ_SCDB_XYR – 表_侦监_审查逮捕_嫌疑人T_ZJ_SCDB_XYR_AY – 表_侦监_审查逮捕_嫌疑人_案由T_ZJ_SCDB_XYR_AY_XJ – 表_侦监_审查逮捕_嫌疑人_案由_细节 12.字段命名C_XM – 姓名N_XB – 性别N_BH – 编号D_CSRQ – 出生日期D_TCSJ – 提出时间 13.主键命名PK_XS_BS – 表XS以字段BS创建主键 14.外键命名FK_XS_DSR – 在表XS的字段DSR上创建外键 15.索引命名IDX_FJWZFP_NSRDZDAH_NSRLX – 索引_废旧物资发票表_电子档案号_纳税人类型 16.视图命名V_ZJ_SCDB_WS – 视图_侦监_审查逮捕_文书 17.函数命名FN_CREATE_N_ID – 函数_创建id 18.触发器命名TR_AJGL_IU – 对AJGL表进行插入、更新的触发器 19.SQL如果删除表中全部行，不准使用delete，而应该使用truncate；select 语句中，不允许在where后面加上类似 “1 = 1” 的条件；select 语句中，对不应该使用distinct的地方不使用；select 语句中，尽量枚举所有字段，避免使用”*” 数据库编码范例select 语句12345select N_ID, N_BH, C_XM, C_AH from T_REPCONFIGINFO_DEF where N_LX = 1 and C_C_AH = '审查逮捕2006第一号' update 语句12345678910111213update T_REPCONFIGINFO_DEF set N_ID = 1000000000000, N_BH = 1000000000001, C_XM = '姓名', C_AH = '案号', D_LARQ = '20080808', D_SARQ = '20080808', D_JARQ = '20080808', D_CSRQ = '20080808', N_CLJG = 1 where N_LX = 1 and C_AH = '审查逮捕2006第一号' insert 语句12345insert into T_AJGL_LX( C_AH, N_SL, N_DJ ) values ( '反贪立案案件', 1, 5)insert into T_AJGL_LX( C_AH, N_SL, N_DJ ) values ( '反贪立案案件', 2, 6)insert into T_AJGL_LX( C_AH, N_SL, N_DJ ) values ( '反贪立案案件', 3, 7)insert into T_AJGL_LX( C_AH, N_SL, N_DJ ) values ( '反贪立案案件', 4, 8) 建表123456789101112131415161718create table OLAP20.FACT_FPCGL( C_FPDM char(10 byte) not null, -- 发票代码 C_FPHM char(8 byte) not null, -- 发票号码 N_SL number(19,2) null, -- 税率 C_HY_DM_OLD varchar2(6 byte) null, -- 行业代码 C_NSR_SWJG_DM char(11 byte) null, -- 纳税人税务机构代码 C_DJZCLX_DM char(3 byte) null, -- 登记注册类型代码 C_ZGSWRY_DM varchar2(11 byte) null, -- 主管税务人员代码 C_GSYLB_DM char(1 byte) null, -- 工商业类别代码 C_LSGX_DM char(2 byte) null, -- 隶属关系代码 C_NSRZT_DM char(2 byte) null, -- 纳税人状态代码 C_JDXZ_DM char(10 byte) null, -- 街道乡镇代码 C_HY_DM varchar2(6 byte) null, -- 行业明细代码 N_NSRDZDAH number(20) null, -- 纳税人电子档案号 C_BBQ varchar2(8 byte) null -- 报表期 ) 建视图123456789101112131415create or replace force view OLAP20.V_TasK_LOGas ( select to_char(D_LDATE, 'MM-DD, HH24:MI:SS') \"TIME\", PLOG.GETLEVELINTEXT(LLEVEL) \"LEVEL\", C_LUSER \"USER\", C_LSECTION \"SECTION\", C_LTEXTE \"TEXT\" from (select * from TLOG where C_LSECTION = 'PK_TasK' order by N_ID DESC)); 不规范代码123456789101112if(ts==null)&#123; return \"ok\";&#125;for (int i = 0; i &lt; list.size(); i++) &#123; if (list.get(i) == null || list.get(i) == \"\") &#123; continue; &#125; sb.append(list.get(i).trim()); sb.append(\";\");&#125; 12345678910111213141516if (StringUtils.isNotBlank(dqdw) &amp;&amp; FxryConsts.CORP_ID_FJ.equals(dqdw)) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); result.append(\" and (\" + qxsql + \" in (SELECT C_ID FROM DB_JY..T_SYS_CORP WHERE C_ID= \" + FxryConsts.CORP_ID_FJ + \" OR C_PID = \" + FxryConsts.CORP_ID_FJ + \" OR C_ID = \" + FxryConsts.CORP_ID_SJ + \" )) \"); return result.toString();&#125;Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();StringBuffer sql = new StringBuffer();sql.append(***);sql.append(\" from DB_ZFJY..T_YNGW_DD dd left join DB_ZFJY..T_YNGW_WP wp on dd.C_WPID =wp.C_ID \");sql.append(\" left join DB_JY..T_ZF_JBXX jbxx on jbxx.N_ZFXH =dd.C_ZFID left join \"); 123456789101112131415161718192021222324252627282930313233343536public Object ds_rs3(IQueryInfo qp) &#123; String sjbh = ArteryParamUtil.getString(\"sjbh\"); int count = service.doQueryStts(sjbh); List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); if (count % DmConsts.RS_NO_FIVE == 0) &#123; for (int i = 0; i &lt; count / DmConsts.RS_NO_FIVE; i++) &#123; Map&lt;String, Object&gt; m = new HashMap&lt;String, Object&gt;(); m.put(\"text\", i * DmConsts.RS_NO_FIVE + 1 + \"...\" + (i + 1) * DmConsts.RS_NO_FIVE + \"题\"); list.add(m); &#125; &#125; else &#123; for (int i = 0; i &lt; count / DmConsts.RS_NO_FIVE + 1; i++) &#123; Map&lt;String, Object&gt; m = new HashMap&lt;String, Object&gt;(); if (count % DmConsts.RS_NO_FIVE == 1) &#123; if (i == count / DmConsts.RS_NO_FIVE) &#123; m.put(\"text\", count + \"题\"); &#125; else &#123; m.put(\"text\", i * DmConsts.RS_NO_FIVE + 1 + \"...\" + (i + 1) * DmConsts.RS_NO_FIVE + \"题\"); &#125; &#125; else &#123; if (i == count / DmConsts.RS_NO_FIVE) &#123; m.put(\"text\", i * DmConsts.RS_NO_FIVE + 1 + \"...\" + count + \"题\"); &#125; else &#123; m.put(\"text\", i * DmConsts.RS_NO_FIVE + 1 + \"...\" + (i + 1) * DmConsts.RS_NO_FIVE + \"题\"); &#125; &#125; list.add(m); &#125; &#125; return list;&#125; 123456YlaMgajDto ylaDto = (YlaMgajDto) result.get(\"ylaMgajDto\");List&lt;YlaDsrDto&gt; dsrDtos = new ArrayList&lt;YlaDsrDto&gt;();YlaAyDto ayDto = ylaDto.getAyDto();if (ylaDto != null) &#123; dsrDtos = ylaDto.getDsrDtos();&#125; 问题：第三行已经使用ylaDao了，第四行还判空有意义么？如果if成立，那么第二行new的ArrayList就多余了。 1234567891011Map map = new HashMap();Document document = null;try &#123; map = webserviceUtil.bean2map(object); Element root = DocumentHelper.createElement(\"root\"); document = DocumentHelper.createDocument(root); ******&#125; catch (Exception e) &#123; e.printStackTrace();&#125;return document.asXML(); 问题：webserviceUtil.bean2map(object)如果抛出异常，document为null，document.asXML()会抛出NPE。 12345678910111213141516171819202122232425262728293031323334353637function setData1(data) &#123; $('.fd-tab1-right .fd-div-content').html(''); $('.fd-select-03').html(''); $('.fd-select-04').html(''); $('.fd-tab1-right .fd-item-showAll').html('展开全部'); var sum=0; for(var k=0;k&lt;data.length;k++)&#123; sum+=data[k].count; &#125; for (var i = 0; i &lt; data.length; i++) &#123; ***** // bottom for (var m = 0; m &lt;time.info.length; m++) &#123; var html = ''; if (time.info[m].name == '周') &#123; html = \"&lt;option selected value=\" + m + \"&gt;\" + time.info[m].name +\"&lt;/option&gt;\"; &#125; else &#123; html = \"&lt;option value=\" + m + \"&gt;\" + time.info[m].name +\"&lt;/option&gt;\"; &#125; $('.fd-select-03').append(html); if (m == 0) &#123; var obj=countIndustryUse(); var jsonarr=[ [\"政法委\",obj[ZFW]!=undefined?obj[ZFW]:0], [\"法院\",obj[FY]!=undefined?obj[FY]:0], [\"检察\",obj[JC]!=undefined?obj[JC]:0], [\"公安\",obj[GA]!=undefined?obj[GA]:0], [\"司法\",obj[SF]!=undefined?obj[SF]:0], [\"行政\",obj[XZ]!=undefined?obj[XZ]:0], [\"其他\",obj[QT]!=undefined?obj[QT]:0] ]; $('#js-line1').highcharts(getOption_pie2(jsonarr,'数据资源')); &#125; &#125; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445//根据系统名获取到业务的数据量 当systemName为空的时候 查询所有系统的数据量function countIndustryUse(systemName)&#123; var tableIndustryObj=&#123;&#125;; var tmpTableIndustryObj=&#123;&#125;; for(var key in data)&#123; var system=data[key]; var tables=system.tables; if(systemName)&#123; if(systemName==key)&#123; for(var i=0;i&lt;tables.length;i++)&#123; var table=tables[i]; var industryName=table.industryName; var value=table.dataNum; if(tableIndustryObj[industryName])&#123; tableIndustryObj[industryName]+=value; &#125;else&#123; tableIndustryObj[industryName]=value; &#125; &#125; &#125; &#125;else&#123; for(var i=0;i&lt;tables.length;i++)&#123; var table=tables[i]; var industryName=table.industryName; var tableName=table.tableName; var value=table.dataNum; if(!tmpTableIndustryObj[industryName+'_'+tableName])&#123; tmpTableIndustryObj[industryName+'_'+tableName]=value; &#125; &#125; &#125; &#125; if(!systemName)&#123; for(var tmpkey in tmpTableIndustryObj)&#123; var industryValue=tmpkey.substring(0,tmpkey.indexOf('_')); if(tableIndustryObj[industryValue])&#123; tableIndustryObj[industryValue]+=tmpTableIndustryObj[tmpkey]; &#125;else&#123; tableIndustryObj[industryValue]=tmpTableIndustryObj[tmpkey]; &#125; &#125; &#125; return tableIndustryObj;&#125; 1234String str=\"Hello!\";str.substring(1,2);System.out.println(str); ? 123456789101112131415161718192021222324252627282930private static final ReentrantLock ftpDownLoadLock = new ReentrantLock();public static boolean downFileFromFTP(...) &#123; try &#123; .... FTPFile[] fs = ftpClient.listFiles(fileUrl); for (FTPFile ff : fs) &#123; if (ff.getName().equals(fileName)) &#123; ... if(localFile.exists())&#123; return true; &#125;else&#123; ftpDownLoadLock.lock(); if(localFile.exists())&#123; ftpDownLoadLock.unlock(); return true; &#125; ... ftpDownLoadLock.unlock(); &#125; &#125; &#125; ftpClient.logout(); &#125; catch (IOException e) &#123; logger.error(\"从ftp下载文件出错\" + e); &#125; finally &#123; ... &#125; return result; &#125; 1234*** String kssj = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(dtKssj); String jssj = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(dtJssj);**** 几个小问题(PostgreSQL或Abase)问题一create table c_test( “C_BH” char(32)); INSERT INTO c_test VALUES (‘444’); select * from c_test where C_BH=’444’; 结果？ select * from c_test where “C_BH”=’444’; 结果？ 问题二create table c_test( C_BH char(32)); INSERT INTO c_test VALUES (‘444’); select * from c_test where C_BH=’444’; 结果？ select * from c_test where “C_BH”=’444’; 结果？ 问题三create table c_test( “c_bh” char(32)); INSERT INTO c_test VALUES (‘444’); select * from c_test where c_bh=’444’; 结果？ select * from c_test where “c_bh”=’444’; 结果？","tags":[{"name":"java","slug":"java","permalink":"http://127.0.0.1:4000/tags/java/"}]},{"title":"GoogleJava编程风格指南","date":"2019-05-10T01:02:25.000Z","path":"2019/05/10/GoogleJava编程风格指南/","text":"1 前言这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。 与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。 1.1 术语说明本文档中除非特殊说明，否则： 术语class可表示一个普通类、枚举类、接口或者注解。 术语comment只用来指代实现的注释(implementation comments)，我们不使用文档注释(documentation comments)一词，而是用Javadoc。 其他术语说明，将在文档中需要说明的地方单独说明。 1.2 指南说明本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。示例中的格式选择不应该被强制定为规则。 2 源文件基础2.1 文件名源文件以其最顶层的类名（其中只有一个）来命名，大小写敏感，文件扩展名为.java。 2.2 文件编码：UTF-8源文件编码格式使用UTF-8。 2.3 特殊字符2.3.1 空格字符除了换行符外，ASCII水平空白字符（0x20）是源码文件中唯一支持的空格字符。这意味着： 所有其他空白字符将被转义。 Tab字符不被用作缩进控制。 2.3.2 特殊转义字符串任何需要转义字符串表示的字符（例如：\\b, \\t, \\n, \\f, \\r, \\&#39;, \\\\等），采用这种转义字符串的方式表示，而不采用对应字符的八进制数（例如 \\012）或Unicode码（例如：\\u000a）表示。 2.3.3 非ASCII字符对于其余非ASCII字符，直接使用Unicode字符（例如 ∞），或者使用对应的Unicode码（例如：\\u221e）转义，都是允许的。唯一需要考虑的是，何种方式更能使代码容易阅读和理解。 注意：在使用Unicode码转义，或者甚至是有时直接使用Unicode字符的时候，建议多添加一些注释说明，将对别人读懂代码很有帮助。 例子： 示例 结论 String unitAbbrev = “μs”; 赞：即使没有注释也非常清晰。 String unitAbbrev = “\\u03bcs”; // “μs” 允许，但没有理由要这样做。 String unitAbbrev = “\\u03bcs”; // Greek letter mu, “s” 允许，但这样做显得笨拙还容易出错。 String unitAbbrev = “\\u03bcs”; 很糟：读者根本看不出这是什么。 return ‘\\ufeff’ + content; // byte order mark 很好：对于非打印字符，使用转义，并在必要时写上注释。 注意：永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行，你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话) 3 源文件结构源文件按照先后顺序，由以下几部分组成： 许可证(License)或版权信息(copyright)（如果需要） package语句 import语句 class类声明（每个源码文件只能有唯一一个顶级class）。 注意：以上每个部分之间应该只有一个空行作为间隔。 3.1 许可证或版权信息如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。 3.2 package语句package语句不换行，单行长度限制(4.4节)不适用于package语句。(即package语句写在一行里) 3.3 import语句3.3.1 import不使用通配符import语句中不应该使用通配符，不管是否是静态导入。 3.3.2 import不换行import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行) 3.3.3 顺序和间距import语句可分为以下几组，按照顺序，每组由一个空行分隔： 所有的静态导入(static import)归为一组 com.google包的import归为一组 使用的第三方包的导入，每个顶级按字典顺序归为一组。例如：android, com, junit, org, sun java包归为一组 javax包归为一组 注意：同一组内的import语句之间不应用空行隔开，同一组中的import语句按字典序排列。 3.4 类声明3.4.1 只声明唯一一个顶级class每个源文件中只能有一个顶级class。 3.4.2 类成员顺序类成员的顺序对代码的易读性有很大影响，但是没有一个统一正确的标准。不同的类可能有不同的排序方式。 最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如，新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。 3.4.2.1 重载：永不分离当一个类有多个构造函数，或是多个同名方法，这些方法应该按顺序出现在一起，中间不要放进其它方法。 4 格式 术语说明：块状结构(block-­like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。 4.1 大括号4.1.1 使用大括号(即使是可选的)大括号一般用在if, else, for, do, while等语句，即使只有一条语句(或是空)，也应该把大括号写上。 4.1.2 非空语句块采用K&amp;R风格对于非空语句块，大括号遵循Kernighan和Ritchie风格 (Egyptian brackets): 左大括号前不换行 左大括号后换行 右大括号前换行 如果右大括号结束是一个语句块或者方法体、构造函数体或者有命名的类体，则需要换行。当右括号后面接else或者逗号时，不应该换行。 示例： 123456789101112131415161718192021return () -&gt; &#123; while (condition()) &#123; method(); &#125;&#125;;return new MyClass() &#123; @Override public void method() &#123; if (condition()) &#123; try &#123; something(); &#125; catch (ProblemException e) &#123; recover(); &#125; &#125; else if (otherCondition()) &#123; somethingElse(); &#125; else &#123; lastThing(); &#125; &#125;&#125;; 一些例外的情况，将在4.8.1节讲枚举类型的时候讲到。 4.1.3 空语句块：使代码更简洁一个空的语句块，可以在左大括号之后直接接右大括号，中间不需要空格或换行。但是当一个由几个语句块联合组成的语句块时，则需要换行。（例如：if/else 或者try/catch/finally）. 示例： 123456// 这是可接受的void doNothing() &#123;&#125;// 这同样是可接受的void doNothingElse() &#123;&#125; 1234// 这是不可接受的：多块语句中没有简洁的空语句块try &#123; doSomething();&#125; catch (Exception e) &#123;&#125; 4.2块缩进：2个空格每当一个新的语句块产生，缩进就增加两个空格。当这个语句块结束时，缩进恢复到上一层级的缩进格数。缩进要求对整个语句块中的代码和注释都适用。（例子可参考之前4.1.2节中的例子）。 注意：根据实际的编程经验，2个空格缩进的代码在当前大屏的计算机上会显得十分拥挤，反而使得代码臃肿不够美观。所以，我这里建议使用4个空格来缩进，会使得更加美观，而且能侧面督促开发人员减少代码的嵌套层数。 4.3 一行一个语句每条语句结束都需要换行。 4.4 列长度限制：100Java代码的列长度限制为100个字符。 除了如下所述，任何超过此限制的行都必须跳行。这在4.5节会有详细解释。 例外： 不可能满足行长度限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考) package和import语句(见3.2节和3.3节) 注释中那些可能被剪切并粘贴到shell中的命令行 注意：当前的计算机屏幕都已经比很宽了，而且变量及方法命名都较长，100个字符的长度反而会出现很多不必要的跳行，已经不适应当今的情况了，根据实际编程经验，我这里建议使用120个字符的宽度更为合适。 4.5 换行术语说明：一般情况下，一行长代码为了避免超出列限制(100个字符)而被分为多行，我们称之为断行(line­-wrapping)。 我们并没有全面，确定性的准则来决定在每一种情况下如何断行。很多时候，对于同一段代码会有好几种有效的换断行方式。 注意: 提取方法或局部变量可以解决问题，而不不需要进行断行。 4.5.1 在何处断行断行的主要原则是：选择在更高级的语法逻辑处断行。其他一些原则如下： 当一个非赋值运算的语句断行时，在运算符号之前断行。（这与Google的C++规范和JavaScrip规范等其他规范不同）。 如果要在非赋值运算符处断行，那么在该符号前断开(比如+操作符，它将位于下一行)。以下的类运算符也可作为参考： 点操作符. 类型界限中的&amp;、||等（例如：&lt;T extends Foo &amp; Bar&gt;) 当要在一个赋值运算语句处断行时，一般在赋值符号之后断行。但是也可以在之前断行。(例如：=，它与前面的内容留在同一行)。 这条规则也适用于foreach语句中的冒号。 方法名或构造函数名与左括号留在同一行。 逗号(,)与其前面的内容留在同一行。也就是在逗号之后断行。 Lambda表达式在箭头符号(-&gt;)后断行。 示例： 1234567MyLambda&lt;String, Long, Object&gt; lambda = (String label, Long value, Object obj) -&gt; &#123; ... &#125;;Predicate&lt;String&gt; predicate = str -&gt; longExpressionInvolving(str); 注意：换行的主要目标是使代码更清晰易读。 4.5.2 断行的缩进：至少+4个空格自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。 当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。 第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。 4.6 空白4.6.1 垂直空白以下情况需要使用单行空行： 类成员之间需要单个空行隔开：例如：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。但也有以下两种例外情况： 两个连续字段之间的空行是可选的，根据需要使用空行来创建字段间的逻辑分组。 枚举常量之间的的空行也是可选的，根据需要使用空行来创建枚举常量间的逻辑分组。 在方法体内，根据代码的逻辑分组的需要，设置空白行作为间隔。 类的第一个成员之前或最后一个成员之后，使用空行(可选)。 本文档所介绍的其他章节的空行要求(比如3.3节：import语句)。 4.6.2 水平空白除了语法、其他规则、词语分隔、注释和javadoc外，水平的ASCII空格只在以下情况出现： 所有保留的关键字与紧接它之后的位于同一行的左大括号之间需要用空格隔开。(例如：if, for catch等) 所有保留的关键字与在它之前的右大括号之间需要空格隔开。（例如：else、catch） 在左大括号之前都需要空格隔开。只有两种例外： @SomeAnnotation({a, b}) String[][] x = foo; 所有的二元运算符和三元运算符的两边，都需要空格隔开。(例如：a + b、b = a &lt; 0 ? 0 : a) 逗号(,)、冒号(:)、分号(;)和右小括号())、Lambda箭头符号(-&gt;)之后，需要空格隔开。 //双斜线开始一行注释时，双斜线两边都应该用空格隔开。并且可使用多个空格。（可选，例如：a = 0; // 赋值为0） 变量声明时，变量类型和变量名之间需要用空格隔开。（例如：List&lt;String&gt; list） 初始化一个数组时，花括号之间可以用空格隔开，也可以不使用。（可选，例如：new int[] {5, 6}和new int[] { 5, 6 }） 注意：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。 4.6.3 水平对齐：不做要求 术语说明：水平对齐，是指通过添加多个空格，使本行的某一符号与上一行的某一符号上下对齐。 这种对齐是被允许的，但是不会做强制要求。 以下是没有水平对齐和水平对齐的例子： 12345private int x; // 这种挺好private Color color; // 同上private int x; // 允许，但是未来会继续编辑private Color color; // 可能会使它对不齐 注意：水平对齐能够增加代码的可读性，但是增加了未来维护代码的难度。考虑到维护时只需要改变一行代码，之前的对齐可以不需要改动。为了对齐，你更有可能改了一行代码，同时需要更改附近的好几行代码，而这几行代码的改动，可能又会引起一些为了保持对齐的代码改动。那原本这行改动，我们称之为爆炸半径。这种改动，在最坏的情况下可能会导致大量的无意义的工作，即使在最好的情况下，也会影响版本历史信息，减慢代码review的速度，引起更多merge代码冲突的情况。 4.7 分组小括号：推荐使用除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。我们没有理由假设读者能记住整个Java运算符优先级表。 4.8 特殊结构4.8.1 枚举类型枚举常量间用逗号隔开，换行是可选的。而且还允许附加的空行（通常只有一个）。以下就是一种可能性的示例： 12345678910private enum Answer &#123; YES &#123; @Override public String toString() &#123; return \"yes\"; &#125; &#125;, NO, MAYBE&#125; 没有方法和Javadoc的枚举类可写成数组初始化的格式： 1private enum Suit &#123; CLUBS, HEARTS, SPADES, DIAMONDS &#125; 由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。 4.8.2 变量声明4.8.2.1 每次声明一个变量不要使用组合声明。例如：int a, b;是不允许的。 4.8.2.2 需要时才声明，尽快进行初始化不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。 4.8.3 数组4.8.3.1 数组初始化：可写成块状结构数组初始化可以写成块状结构，例如以下格式的写法都是允许的： 123456789new int[] &#123; new int[] &#123; 0, 1, 2, 3 0,&#125; 1, 2,new int[] &#123; 3, 0, 1, &#125; 2, 3&#125; new int[] &#123;0, 1, 2, 3&#125; 4.8.3.2 非C风格的数组声明中括号是类型的一部分：String[] args， 而非String args[]。 4.8.4 switch语句术语说明：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。 4.8.4.1 缩进和其他语句块一样，switch大括号之后缩进两个字符。每个switch标签之后，后面紧接的非标签的新行，按照大括号相同的处理方式缩进两个字符。在标签结束后，恢复到之前的缩进，类似大括号结束。 4.8.4.2 继续向下执行的注释在一个switch块内，每个语句组要么通过break、continue、return或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组，任何能表达这个意思的注释都是可以的(典型的是用// fall through)。这个特殊的注释并不需要在最后一个语句组(一般是default)中出现。例如： 1234567891011switch (input) &#123; case 1: case 2: prepareOneOrTwo(); // fall through case 3: handleOneTwoOrThree(); break; default: handleLargeNumber(input);&#125; 注意：在case 1之后不需要该注释，仅在语句组的末尾。 4.8.4.3 default标签需要显式声明每个switch语句中，都需要显式声明default标签。即使没有任何代码也需要显示声明。 注意：枚举类型的switch语句可以省略default语句组，如果它包含覆盖该类型的所有可能值的显式情况。这使得IDE或其他静态分析工具能够在丢失任何情况时发出警告。 4.8.5 注解注解应用到类、方法或者构造方法时，应紧接Javadoc之后。每一行只有一个注解。注解所在行不受列长度限制，也不需要增加缩进。例如： 123@Override@Nullablepublic String getNameIfPresent() &#123; ... &#125; 例外：如果注解只有一个，并且不带参数。则它可以和类或方法名放在同一行。例如： 1@Override public int hashCode() &#123; ... &#125; 注解应用到成员变量时，也是紧接Javadoc之后。不同的是，多个注解可以放在同一行。例如： 1@Partial @Mock DataLoader loader; 对于参数或者局部变量使用注解的情况，没有特定的规范。 4.8.6 注释4.8.6.1 块注释风格注释的缩进与它所注释的代码缩进相同。可以采用/* */进行注释，也可以用//进行注释。当使用/* */进行多行注释时，每一行都应该以*开始，并且*应该上下对齐。 例如： 12345678910/* * This is * okay. */// And so// is this./* Or you can * even do this. */ 注意：多行注释时，如果你希望集成开发环境能自动对齐注释，你应该使用/* */，//一般不会自动对齐。 4.8.7 修饰符类和成员变量的修饰符，按Java Lauguage Specification中介绍的先后顺序排序。具体是： 1public protected private abstract default static final transient volatile synchronized native strictfp 4.8.8 数字字面量长整型的数字字面量使用大写的L作为后缀，不得使用小写（以免与数字1混淆）。例如：使用3000000000L，而不是3000000000l。 5 命名约定5.1 对所有标识符都通用的规则标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式\\w+。 在Google其它编程语言风格中使用的特殊前缀或后缀，如name_, mName, s_name和kName，在Java编程风格中都不再使用。 5.2 标识符类型的规则5.2.1 包名包名全部小写，连续的单词只是简单地连接起来，不使用下划线。例如：使用com.example.deepspace，而不是com.example.deepSpace或者com.example.deep_space。 5.2.2 类名类名都以UpperCamelCase风格编写。 类名通常是名词或名词短语。例如：Character或者ImmutableList。接口名称也可以是名词或名词短语（例如：List），但有时可能是形容词或形容词短语（例如：Readable）。现在还没有特定的规则或行之有效的约定来命名注解类型。 测试类的命名以它要测试的类的名称开始，以Test结束。例如：HashTest或HashIntegrationTest。 5.2.3 方法名方法名都以lowerCamelCase风格编写。 方法名通常是动词或动词短语。例如：sendMessage或者stop。 下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：test&lt;MethodUnderTest&gt;_&lt;state&gt;，例如：testPop_emptyStack。 并不存在唯一正确的方式来命名测试方法。 5.2.4 常量名常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。那到底什么算是一个常量呢？ 每个常量都是一个静态final字段，其内容是不可变的，且没有可检测的副作用。这包括原始类型、字符串、不可变类型和不可变类型的不可变集合。如果任何一个实例的观测状态是可变的，则它肯定不会是一个常量。只是永远不打算改变对象也是不够的。例如： 1234567891011121314151617// 常量static final int NUMBER = 5;static final ImmutableList&lt;String&gt; NAMES = ImmutableList.of(\"Ed\", \"Ann\");static final ImmutableMap&lt;String, Integer&gt; AGES = ImmutableMap.of(\"Ed\", 35, \"Ann\", 32);static final Joiner COMMA_JOINER = Joiner.on(','); // 因为Joiner是不可变的static final SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;enum SomeEnum &#123; ENUM_CONSTANT &#125;// 非常量static String nonFinal = \"non-final\";final String nonStatic = \"non-static\";static final Set&lt;String&gt; mutableCollection = new HashSet&lt;String&gt;();static final ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);static final ImmutableMap&lt;String, SomeMutableType&gt; mutableValues = ImmutableMap.of(\"Ed\", mutableInstance, \"Ann\", mutableInstance2);static final Logger logger = Logger.getLogger(MyClass.getName());static final String[] nonEmptyArray = &#123;\"these\", \"can\", \"change\"&#125;; 这些常量的名字通常是名词或名词短语。 5.2.5 非常量字段名非常量字段名以lowerCamelCase风格编写。 这些名字通常是名词或名词短语。例如：computedValues或者index。 5.2.6 参数名参数名以lowerCamelCase风格编写。 参数应该避免用单个字符命名。 5.2.7 局部变量名局部变量名以lowerCamelCase风格编写。 即使局部变量是final和不可改变的，也不应该把它示为常量，当然也就不能用常量的规则去命名它。 5.2.8 类型变量名类型变量可用以下两种风格之一进行命名： 单个的大写字母，后面可以视具体情况跟一个数字(如：E, T, X, T2)。 以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。 5.3 驼峰式命名法(CamelCase)驼峰式命名法分大驼峰式命名法(UpperCamelCase)和小驼峰式命名法(lowerCamelCase)。有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如：IPv6或iOS)。Google指定了以下的转换方案。 名字从散文形式(prose form)开始: 把短语转换为纯ASCII码，并且移除任何单引号。例如：Müller’s algorithm将变成Muellers algorithm。 把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。 推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如AdWords将分割成ad words)。 需要注意的是iOS并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。 现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写： 每个单词的第一个字母都大写，来得到大驼峰式命名。 除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。 最后将所有的单词连接起来得到一个标识符。 示例： 散文形式 正确 不正确 “XML HTTP request” XmlHttpRequest XMLHTTPRequest “new customer ID” newCustomerId newCustomerID “inner stopwatch” innerStopwatch innerStopWatch “supports IPv6 on iOS?” supportsIpv6OnIos supportsIPv6OnIOS “YouTube importer” YouTubeImporter YoutubeImporter^ 无 加^号处表示可以，但不推荐。 注意：在英语中，某些带有连字符的单词形式不唯一。例如：nonempty和non-empty都是正确的，因此方法名checkNonempty和checkNonEmpty也都是正确的。 6 编程实践6.1 @Override：总是使用只要是合法的方法，就把@Override注解加上。这包括覆盖超类方法的类方法，实现接口方法的类方法。 例外：当父方法为@Deprecated时，可以省略@Override。 6.2 捕获的异常：不能忽视除了下面的例子，对捕获的异常不做任何响应是极少的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个AssertionError重新抛出。) 如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。 1234567try &#123; int i = Integer.parseInt(response); return handleNumericResponse(i);&#125; catch (NumberFormatException ok) &#123; // 它不是一个数字，不过没关系，继续&#125;return handleTextResponse(response); 例外：在测试中，如果一个捕获的异常被命名为expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。 12345try &#123; emptyStack.pop(); fail();&#125; catch (NoSuchElementException expected) &#123;&#125; 6.3 静态成员：使用类来调用 使用类名调用静态的类成员，而不是具体某个对象或表达式。 1234Foo aFoo = ...;Foo.aStaticMethod(); // 好aFoo.aStaticMethod(); // 糟somethingThatYieldsAFoo().aStaticMethod(); // 很糟 6.4 Finalizers: 禁用 极少会去重载Object.finalize。 注意：不要使用finalize。如果你非要使用它，请先仔细阅读和理解Effective Java第7条款：“Avoid Finalizers”，然后不要使用它。 7 Javadoc7.1 格式7.1.1 一般形式Javadoc块的基本格式如下所示： 12345/** * Multiple lines of Javadoc text are written here, * wrapped normally... */public int method(String p1) &#123; ... &#125; 或者是以下单行形式： 1/** An especially short bit of Javadoc. */ 基本格式总是可以接受的。当整个Javadoc块能容纳于一行时(且没有标记@XXX)，就可以使用单行形式。 7.1.2 段落空行(只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签&lt;p&gt;，并且它和第一个单词间没有空格。 7.1.3 Javadoc标记标准的Javadoc标记按以下顺序出现：@param, @return, @throws, @deprecated, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格(注：如果你的缩进统一采用采用4个空格，那么这里就应该是8个空格)。 7.2 摘要片段每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。 这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以A {@code Foo} is a...或者This method returns...开头, 它也不会是一个完整的祈使句，如Save the record.。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。 注意：一个常见的错误是把简单的Javadoc写成/** @return the customer ID */，这是不正确的。它应该写成/** Returns the customer ID. */。 7.3 在哪里使用Javadoc至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外： 7.3.1 例外：不言自明的方法对于简单明显的方法如getFoo，Javadoc是可选的(可以不写)。这种情况下除了写Returns the foo，确实也没有什么值得写了。 单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。 注意：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名getCanonicalName，就不应该忽视文档说明，因为读者很可能不知道词语canonical name指的是什么。 7.3.2 例外：重载如果一个方法重载了超类中的方法，那么Javadoc并非必需的。 7.3.3 可选的Javadoc对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。","tags":[{"name":"java","slug":"java","permalink":"http://127.0.0.1:4000/tags/java/"}]}]